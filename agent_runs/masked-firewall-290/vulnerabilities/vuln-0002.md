# Unauthenticated IDOR: /sure/case/{pk}/questionnaire/ exposes case questionnaires by ID

**ID:** vuln-0002
**Severity:** HIGH
**Found:** 2025-11-13 14:30:48 UTC

## Description

Executive summary:
  An unauthenticated Insecure Direct Object Reference (IDOR) exists at:
    GET /sure/case/{pk}/questionnaire/
  This endpoint returns a case's questionnaire by case identifier without requiring authentication or server-side token validation. An attacker who knows or enumerates a valid case identifier can retrieve questionnaire contents (potentially sensitive PII/PHI). This is a high-severity data exposure risk.

Affected files (evidence + lines):
  1) /workspace/sure/sure/api.py  (lines ~79-86)
     @router.get("/case/{pk}/questionnaire/", response=QuestionnaireSchema, auth=None)
     def get_case_questionnaire(request, pk: str):
         pk = strip_id(pk)
         visit = get_object_or_404(Visit, case_id=pk)
         questionnaire = _prefetch_questionnaire().get(pk=visit.questionnaire.pk)
         return questionnaire

  2) /workspace/sure/sure/client_service.py (related code paths; lines ~72-91 and ~112-133)
     get_case_link(case) -> settings.SITE_URL + "?case=" + case.human_id
     send_case_link(...) builds a link with "&token=" + token and sends via SMS
     verify_token(token, phone_number, use=False) locates a token with:
         valid_token = contact.tokens.filter(token=token, used_at__isnull=True).first()
     If use=True the code sets valid_token.used_at = timezone.now() and saves (non-atomic).

  3) /workspace/sure/sure/models.py (Token model lines ~140-154)
     class Token(models.Model):
         contact = models.ForeignKey(Contact, ...)
         token = models.CharField(max_length=64, default=generate_token, unique=True)
         created_at = models.DateTimeField(auto_now_add=True)
         used_at = models.DateTimeField(blank=True, null=True)

Technical description:
  - The endpoint at /sure/case/{pk}/questionnaire/ is explicitly exposed without authentication (auth=None). It obtains the Visit by case_id and returns the questionnaire data.
  - strip_id() only normalizes the human-readable prefix (SUC-/SUF-); it does not perform authorization checks.
  - Token-based flows exist elsewhere (send_case_link, send_token), but tokens are not required to access this endpoint; the token mechanism is inconsistent with publicly-exposed case endpoints.
  - Token consumption is implemented with a read-then-write pattern (filter(...).first() then set used_at). This is non-atomic and creates a TOCTOU race window for token reuse (demonstrated in separate tests).
  - Because the case identifier scheme uses short base58 IDs (CASE_ID_LENGTH = 6), enumeration may be feasible at scale and combined with other leak vectors (logs, referer, SMS forwarding).

Proof-of-Concept (PoC) — unauthenticated GET:
  - Environment assumption: application reachable at http://localhost:8000 (development or local test).
  - Example HTTP request (no authentication required; GET is sufficient):
    curl -i 'http://localhost:8000/sure/case/SUF-<CASE_ID>/questionnaire/'

  - Example expected response (successful case id):
    HTTP/1.1 200 OK
    Content-Type: application/json
    {
      "id": 12,
      "name": "Sample Questionnaire",
      "sections": [
        {
          "id": 1,
          "title": "Symptoms",
          "questions": [
            { "id": 123, "text": "Do you have fever?" },
            ...
          ]
        },
        ...
      ]
    }

  - Example negative case (invalid id):
    HTTP/1.1 404 Not Found

Reproduction steps (safe, non-destructive):
  1) Prepare test environment (recommended: local workstation or isolated test VM)
     - cd /workspace/sure
     - (optional) activate virtualenv if available:
         source .venv/bin/activate
     - Install dependencies if needed:
         pip install -r requirements.txt
       OR use project's pyproject/poetry workflow
     - Apply migrations (local DB):
         python manage.py migrate
     - Start dev server:
         python manage.py runserver 0.0.0.0:8000
  2) Issue PoC GET:
     curl -i 'http://localhost:8000/sure/case/SUF-<CASE_ID>/questionnaire/'
     - Replace <CASE_ID> with an existing case id (from fixtures or DB)
     - Observe 200/JSON response with questionnaire data — no authentication required.
  3) To confirm sensitivity:
     - Inspect returned JSON for questionnaire contents, question text, or links that may contain PII/PHI.
     - Confirm that no authentication/CSRF token/cookie is required for this GET.

Impact assessment / business risk:
  - Confidentiality: HIGH — Questionnaire contents often include health-related questions, test results, or PII.
  - Integrity: LOW — This endpoint appears read-only; it exposes data rather than mutating it.
  - Availability: NONE
  - Business impact:
      * Unauthorized exposure of sensitive client/health data (regulatory risk — GDPR/HIPAA depending on region).
      * Reputational damage and potential legal/regulatory fines.
      * Aggregation of leaked questionnaires can enable targeted attacks or social engineering.
  - Proposed CVSS v3.1 base assessment (recommendation):
      AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N => CVSS 3.1 Base Score ≈ 7.5 (High).
    Rationale: Network attack vector, no privileges required, low complexity, high confidentiality impact.

Exploitation / enumeration math and feasibility:
  - Case identifier space:
      BASE_58 alphabet, CASE_ID_LENGTH = 6
      Search space = 58^6 = 38,068,692,544 (~3.8e10)
  - Expected attempts to find a valid case (random sampling):
      Expected attempts ≈ (58^6) / N where N is number of existing cases
  - Examples at 100 requests/sec:
      * N = 1,000  -> expected attempts ≈ 38,068,693  -> ~ 4.4 days at 100 req/s
      * N = 10,000 -> expected attempts ≈ 3,806,869   -> ~ 10.6 hours at 100 req/s
      * N = 100,000 -> expected attempts ≈ 380,687    -> ~ 1.06 hours at 100 req/s
  - Notes:
      * Enumeration becomes tractable with higher case counts and parallelization.
      * Secondary leakage (logs, analytics, SMS forwarding, referer headers) can drastically reduce search space.
      * Because many endpoints are not rate-limited, attackers with modest resources can scan the available space.

Root causes:
  1) Endpoint explicitly configured as unauthenticated (auth=None) while returning sensitive data.
  2) Inconsistent access control: token-based flows exist but are not enforced on public read endpoints.
  3) Short case identifier length makes enumeration feasible at scale.
  4) Non-atomic token consumption logic elsewhere increases the risk for token replay if tokens are used to protect other flows.

Remediation (code-level fixes & operational mitigations):

  Immediate (0–24 hours)
    - Require authentication on the endpoint or validate a server-side, one-time token before returning sensitive data.
      * Quick fix: remove auth=None on the route so that default API auth is enforced; OR explicitly require auth/authorization.
      * If public, client-facing links are required: implement a dedicated verify endpoint that consumes the token atomically and then issues a short-lived session/cookie or performs a redirect to a token-free URL.

  Code patch suggestions (examples):

    1) sure/api.py — require auth on questionnaire endpoint
       --- a/sure/api.py
       +++ b/sure/api.py
       @@
       -@router.get("/case/{pk}/questionnaire/", response=QuestionnaireSchema, auth=None)
       -def get_case_questionnaire(request, pk: str):
       -    pk = strip_id(pk)
       -    visit = get_object_or_404(Visit, case_id=pk)
       -    questionnaire = _prefetch_questionnaire().get(pk=visit.questionnaire.pk)
       -    return questionnaire
       +@router.get("/case/{pk}/questionnaire/", response=QuestionnaireSchema)
       +def get_case_questionnaire(request, pk: str):
       +    # Enforce authentication (use Ninja auth or explicit check)
       +    if not request.user.is_authenticated:
       +        from ninja.errors import HttpError
       +        raise HttpError(401, "Authentication required")
       +    pk = strip_id(pk)
       +    visit = get_object_or_404(Visit, case_id=pk)
       +    questionnaire = _prefetch_questionnaire().get(pk=visit.questionnaire.pk)
       +    return questionnaire

       Note: Prefer using the API framework's auth integration (e.g., remove auth=None so parent NinjaAPI auth applies)
       or set auth=django_auth explicitly.

    2) sure/client_service.py — atomic token consumption example (preferred pattern)
       --- a/sure/client_service.py
       +++ b/sure/client_service.py
       @@
       -    valid_token = contact.tokens.filter(token=token, used_at__isnull=True).first()
       -    if not valid_token:
       -        return None
       -    if use:
       -        valid_token.used_at = timezone.now()
       -        valid_token.save()
       -    return contact
       +    # Atomic consumption: single UPDATE to avoid TOCTOU race
       +    if use:
       +        now = timezone.now()
       +        updated = contact.tokens.filter(token=token, used_at__isnull=True).update(used_at=now)
       +        if updated == 0:
       +            # no valid token (already used or invalid)
       +            return None
       +        return contact
       +    else:
       +        # existence check without consuming
       +        exists = contact.tokens.filter(token=token, used_at__isnull=True).exists()
       +        return contact if exists else None

       Alternative (select_for_update within a transaction):
       +    from django.db import transaction
       +    with transaction.atomic():
       +        t = contact.tokens.select_for_update().filter(token=token, used_at__isnull=True).first()
       +        if not t:
       +            return None
       +        t.used_at = timezone.now()
       +        t.save()
       +        return contact

    3) sure/models.py — token TTL (recommended)
       --- a/sure/models.py
       +++ b/sure/models.py
       @@
       class Token(models.Model):
           contact = models.ForeignKey(Contact, on_delete=models.CASCADE, related_name="tokens")
           token = models.CharField(max_length=64, verbose_name=_("Token"), default=generate_token, unique=True)
           created_at = models.DateTimeField(auto_now_add=True, verbose_name=_("Created At"))
           used_at = models.DateTimeField(blank=True, null=True, verbose_name=_("Used At"))
       +    expires_at = models.DateTimeField(blank=True, null=True, verbose_name=_("Expires At"))

       +# When generating tokens, set expires_at = timezone.now() + timedelta(hours=1) (short TTL)

    4) Increase case id entropy (longer id or use UUID)
       - Option A: increase CASE_ID_LENGTH from 6 to >=10 (requires migrations).
       - Option B: switch to UUIDField for case primary key (recommended for long-term security).

  Operational mitigations (short/medium term)
    - Add per-IP and per-endpoint rate limiting (e.g., per IP or per token) to slow enumeration.
    - Configure WAF or reverse proxy rules to detect high-volume enumeration and block/alert.
    - Avoid embedding long-lived tokens or identifiers in query strings that may be recorded by logs and referer headers.
    - Redact query strings containing tokens in server/NGINX logs.
    - Rotate any leaked credentials and audit logs for abuse.

Recommended tests to validate the fix:
  1) Unit tests:
     - Ensure endpoint returns 401 for unauthenticated requests after enforcement.
     - Ensure token verification endpoint consumes token atomically (mock DB update and assert single update).
  2) Concurrency test:
     - Use a small script (ThreadPoolExecutor or asyncio) to issue N concurrent requests that consume the same token (use=True) and confirm only 1 request results in token consumption (others fail).
     - Example test outline:
         - Create Contact and token
         - Launch 10 parallel requests to the endpoint that consumes the token
         - Assert 1 success and 9 failures
  3) Enumeration resistance test:
     - Sample 1000 random case IDs and measure hit ratio and response rate limiting behavior.

References:
  - Django transactions and row locking: https://docs.djangoproject.com/en/stable/topics/db/transactions/#select-for-update
  - Using update(...) to atomically modify rows and check affected rows (Django QuerySet.update)
  - OWASP IDOR guidance: https://owasp.org/www-project-top-ten/ (Access Control)
  - CVSS v3.1 specification: https://www.first.org/cvss/specification-document

Conclusion & next steps:
  - This is a confirmed unauthenticated IDOR (HIGH). It allows unauthenticated retrieval of questionnaire data by case ID.
  - Immediate remediation: require authentication or move to a token-verified flow that consumes tokens atomically and redirects to token-free URLs.
  - I recommend applying the atomic token consumption change and adding authentication to the public case endpoints as a priority.
  - After remediation, run the unit and concurrency tests above to validate fixes.

Evidence and reproduction material included above. If desired, I can:
  - Provide a concrete git patch (diff file) applying the changes above and run tests.
  - Spawn a Fixing Agent to implement the code changes, run migrations/tests, and validate the fix dynamically.
